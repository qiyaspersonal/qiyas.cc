<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Duck Hunt</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #3FBFFF; /* NES Sky Blue */
            overflow: hidden;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Minimal Webcam Overlay */
        #webcam_container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 4px solid #fff;
            border-radius: 4px;
            overflow: hidden;
            opacity: 0.8;
            transform: scaleX(-1);
            z-index: 10;
            background: #000;
        }

        #input_video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 5;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            text-shadow: 2px 2px #000;
            pointer-events: none;
        }

        .hud-controls {
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }

        .btn {
            background: #ff5555;
            border: 4px solid #fff;
            color: white;
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            font-size: 12px;
            box-shadow: 4px 4px 0px #000;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #000;
        }

        .btn.active-mode {
            background: #55ff55;
            color: #000;
        }

        .score-box {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border: 2px solid white;
        }

        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
        }

        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }

        /* Hand Status Indicator */
        #hand-status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border: 2px solid white;
            font-size: 12px;
            text-align: left;
            z-index: 10;
            line-height: 1.5;
            pointer-events: none;
        }

        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .red { background-color: #ff5555; }
        .green { background-color: #55ff55; }
        .yellow { background-color: #ffff55; }

    </style>
</head>
<body>
  <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="webcam_container">
            <video id="input_video" playsinline></video>
        </div>

        <div class="ui-layer">
            <div class="hud">
                <div class="hud-controls">
                    <button id="mode-btn" class="btn">MODE: MANUAL</button>
                </div>
                <div style="display: flex; gap: 20px;">
                    <div class="score-box">SCORE: <span id="score">00000</span></div>
                    <div class="score-box" id="round-display">R: 1</div>
                </div>
            </div>
        </div>

        <div id="hand-status">
            <div><span id="detect-dot" class="status-dot red"></span>HAND DETECTED</div>
            <div id="hammer-status-row"><span id="ready-dot" class="status-dot red"></span>HAMMER COCKED</div>
            <div id="instruction-text" style="margin-top:5px; color:#aaa; font-size:10px;">Point with Index. Drop Thumb to Fire.</div>
        </div>

        <div id="loading-screen">
            <h1 style="color: #3FBFFF; text-shadow: 4px 4px #000; font-size: 40px; margin-bottom: 20px;">AI DUCK HUNT</h1>
            <p id="loading-text" class="blink">CLICK TO START</p>
            <p style="font-size: 12px; color: #888; margin-top: 50px; max-width: 600px;">
                Camera access required.<br>
                Please allow camera when prompted.
            </p>
        </div>
  </div>


  <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                sky: '#3FBFFF',
                grass: '#83D313',
                dirt: '#9C4A00',
                crosshair: '#FF0000',
                crosshairAuto: '#00FF00',
                crosshairReload: '#FFFF00',
                flash: '#FFFFFF'
            },
            game: {
                gravity: 0.25,
                friction: 0.98,
                maxDucks: 3,
                groundLevelRatio: 0.75
            },
            vision: {
                smoothing: 0.2, 
                triggerThreshold: 0.04 
            }
        };

        // --- GLOBAL STATE ---
        const state = {
            score: 0,
            round: 1,
            ducks: [],
            shots: [], 
            cursor: { x: 0, y: 0, rawX: 0, rawY: 0 },
            handDetected: false,
            triggerState: 'IDLE',
            shootingMode: 'MANUAL',
            autoFireCooldown: 0,
            gameStarted: false
        };

        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function initAudio() {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playShootSound() {
            if(audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function playHitSound() {
            if(audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
        function playThudSound() {
            if(audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        // --- ASSETS ---
        const SPRITE_DUCK_FLY = [
            [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0],
            [0,0,0,0,0,1,4,4,4,4,4,4,4,1,0,0],
            [0,0,0,0,1,4,2,2,4,4,4,4,4,1,0,0],
            [0,0,0,1,4,2,1,2,4,4,4,4,4,1,0,0],
            [0,0,1,4,4,2,2,2,4,4,4,4,4,1,0,0],
            [0,1,4,4,4,4,4,4,4,4,4,4,4,1,0,0],
            [1,5,5,5,5,4,4,4,4,4,4,4,1,3,3,1],
            [1,5,5,5,5,5,4,4,4,4,4,1,3,3,3,1],
            [1,5,5,5,5,5,5,4,4,4,1,3,3,3,1,0],
            [0,1,5,5,5,5,5,4,4,4,4,1,1,1,1,0],
            [0,0,1,1,1,1,1,4,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0]
        ];

        const SPRITE_DUCK_UP = [
            [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0],
            [0,0,0,0,0,1,4,4,4,4,4,4,4,1,0,0],
            [0,0,0,0,1,4,2,2,4,4,4,4,4,1,0,0],
            [0,0,0,1,4,2,1,2,4,4,4,4,4,1,0,0],
            [0,0,1,4,4,2,2,2,4,4,4,4,4,1,0,0],
            [0,1,5,5,5,5,4,4,4,4,4,4,4,1,0,0],
            [1,5,5,5,5,5,5,4,4,4,4,4,1,3,3,1],
            [1,5,5,5,5,5,5,4,4,4,4,1,3,3,3,1],
            [0,1,5,5,5,5,5,4,4,4,1,3,3,3,1,0],
            [0,0,1,1,1,5,5,4,4,4,4,1,1,1,1,0],
            [0,0,0,0,0,1,1,4,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0]
        ];

        const SPRITE_DUCK_HIT = [
            [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0],
            [0,0,0,0,0,1,4,2,2,4,4,4,4,1,0,0],
            [0,0,0,0,1,4,2,1,2,4,4,4,4,1,0,0],
            [0,0,0,0,1,4,2,2,2,4,4,4,4,1,0,0],
            [0,0,0,0,0,1,4,4,4,4,4,4,4,1,0,0],
            [0,0,0,0,1,5,5,4,4,4,5,5,1,3,3,1],
            [0,0,0,1,5,5,4,4,4,4,4,5,5,1,3,1],
            [0,0,1,5,5,1,4,4,4,4,4,1,5,5,1,0],
            [0,1,5,5,1,0,1,4,4,4,1,0,1,5,5,1],
            [1,5,5,1,0,0,0,1,1,1,0,0,0,1,5,5,1],
            [1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1]
        ];

        const SPRITE_DUCK_DEAD = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,1,4,4,4,4,4,1,0,0,0],
            [0,0,0,0,0,1,4,4,4,4,4,4,4,1,0,0],
            [0,0,0,0,1,4,2,2,4,4,4,4,4,1,0,0],
            [0,0,0,1,4,2,1,2,4,4,4,4,4,1,0,0],
            [0,0,1,4,4,2,2,2,4,4,4,4,4,1,0,0],
            [0,1,5,5,5,5,4,4,4,4,4,4,4,1,0,0],
            [1,5,5,5,5,5,5,4,4,4,4,4,1,1,1,1],
            [1,5,5,5,5,5,5,4,4,4,4,1,3,3,3,1],
            [0,1,5,5,5,5,5,4,4,4,1,3,3,3,1,0],
            [0,0,1,1,1,5,5,4,4,4,4,1,1,1,1,0],
            [0,0,0,0,0,1,1,4,4,4,4,1,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0]
        ];

        // --- GAME ENGINE ---
        class Duck {
            constructor(canvasWidth, canvasHeight) {
                this.width = 64;
                this.height = 64;
                this.pixelSize = 4;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.x = this.direction === 1 ? -100 : canvasWidth + 100;
                this.y = Math.random() * (canvasHeight * 0.6);
                
                const speed = 4 + (Math.random() * 4) + (state.round * 0.2);
                this.vx = speed * this.direction;
                this.vy = (Math.random() - 0.5) * speed;

                this.state = 'FLYING';
                this.animTimer = 0;
                this.animFrame = 0; 
                this.groundTimer = 0;
                this.colorVariant = Math.floor(Math.random() * 3); 
                
                this.colors = {
                    1: '#000000', 
                    2: '#FFFFFF', 
                    3: '#F8B800', 
                    4: this.getColor(this.colorVariant), 
                    5: '#AAAAAA'  
                };
            }

            getColor(variant) {
                if (variant === 0) return '#747474'; 
                if (variant === 1) return '#3E3E9E'; 
                return '#A62E00'; 
            }

            update(canvasWidth, canvasHeight) {
                const groundY = canvasHeight * CONFIG.game.groundLevelRatio - (this.height / 2);

                if (this.state === 'FLYING') {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.y < 0 || this.y > groundY - 50) this.vy *= -1;

                    this.animTimer++;
                    if (this.animTimer > 8) {
                        this.animFrame = 1 - this.animFrame;
                        this.animTimer = 0;
                    }

                    if ((this.direction === 1 && this.x > canvasWidth + 100) || 
                        (this.direction === -1 && this.x < -100)) {
                        return false; 
                    }

                } else if (this.state === 'HIT') {
                    this.animTimer++;
                    if (this.animTimer > 10) { 
                        this.state = 'FALLING';
                        this.vy = 4; 
                        this.vx = 0;
                    }
                } else if (this.state === 'FALLING') {
                    this.y += this.vy;
                    this.vy += CONFIG.game.gravity; 
                    if (this.y >= groundY) {
                        this.y = groundY;
                        this.state = 'GROUNDED';
                        this.groundTimer = 0;
                        playThudSound();
                    }
                } else if (this.state === 'GROUNDED') {
                    this.groundTimer++;
                    if (this.groundTimer > 60) {
                        return false;
                    }
                }
                return true;
            }

            render(ctx) {
                let spriteMap;
                let flip = this.direction === -1;

                if (this.state === 'FLYING') {
                    spriteMap = this.animFrame === 0 ? SPRITE_DUCK_FLY : SPRITE_DUCK_UP;
                } else if (this.state === 'HIT') {
                    spriteMap = SPRITE_DUCK_HIT;
                    flip = false; 
                } else if (this.state === 'FALLING' || this.state === 'GROUNDED') {
                    spriteMap = SPRITE_DUCK_DEAD; 
                    flip = this.animTimer % 10 < 5;
                    if (this.state === 'GROUNDED') flip = false;
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.state === 'GROUNDED' && this.groundTimer > 40 && this.groundTimer % 4 === 0) {
                    ctx.globalAlpha = 0;
                }

                if (flip) {
                    ctx.scale(-1, 1);
                    ctx.translate(-this.width, 0); 
                }

                const p = this.pixelSize;
                for (let r = 0; r < spriteMap.length; r++) {
                    for (let c = 0; c < spriteMap[r].length; c++) {
                        const colorCode = spriteMap[r][c];
                        if (colorCode !== 0) {
                            ctx.fillStyle = this.colors[colorCode];
                            ctx.fillRect(c * p, r * p, p, p);
                        }
                    }
                }
                ctx.restore();
            }

            checkCollision(cx, cy) {
                if (this.state !== 'FLYING') return false;
                const padding = 10;
                return (cx >= this.x - padding && cx <= this.x + this.width + padding &&
                        cy >= this.y - padding && cy <= this.y + this.height + padding);
            }

            hit() {
                if (this.state !== 'FLYING') return;
                this.state = 'HIT';
                this.animTimer = 0;
                state.score += 500;
                updateScore();
            }
    }
    // --- SETUP ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementById('input_video');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingText = document.getElementById('loading-text');
        const modeBtn = document.getElementById('mode-btn');

        modeBtn.addEventListener('click', () => {
            if (state.shootingMode === 'MANUAL') {
                state.shootingMode = 'AUTO';
                modeBtn.innerText = "MODE: AUTO";
                modeBtn.classList.add('active-mode');
                document.getElementById('instruction-text').innerText = "Hover over duck to AUTO FIRE.";
                document.getElementById('hammer-status-row').style.display = 'none';
            } else {
                state.shootingMode = 'MANUAL';
                modeBtn.innerText = "MODE: MANUAL";
                modeBtn.classList.remove('active-mode');
                document.getElementById('instruction-text').innerText = "Point with Index. Drop Thumb to Fire.";
                document.getElementById('hammer-status-row').style.display = 'block';
            }
        });

        // Start Game Interaction with Explicit Camera Request
        loadingScreen.addEventListener('click', () => {
            if (!state.gameStarted) {
                initAudio();
                state.gameStarted = true;
                loadingText.innerText = "REQUESTING CAMERA...";
                loadingText.classList.remove('blink');
                
                // 1. Explicitly ask for user media FIRST to trigger prompt immediately
                navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } })
                .then(stream => {
                    // Success! Assign stream and start MediaPipe
                    videoElement.srcObject = stream;
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        loadingText.innerText = "INITIALIZING AI...";
                        loadingText.classList.add('blink');
                        
                        // Start MediaPipe Camera Utility which will hook into this video
                        camera.start()
                        .then(() => {
                            requestAnimationFrame(gameLoop);
                        })
                        .catch(err => {
                            console.error("MediaPipe Error:", err);
                        });
                    };
                })
                .catch(err => {
                    console.error("Permission Error:", err);
                    loadingText.innerText = "CAMERA BLOCKED!";
                    loadingText.style.color = "red";
                });
            }
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function updateScore() {
            document.getElementById('score').innerText = state.score.toString().padStart(5, '0');
    }
    // --- INPUT & COMPUTER VISION LOGIC ---
        function onResults(results) {
            // Hide loading screen
            if (state.gameStarted && loadingScreen.style.display !== 'none' && results.multiHandLandmarks) {
                loadingScreen.style.display = 'none';
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. CURSOR
                const indexTip = landmarks[8];
                const targetX = (1 - indexTip.x) * canvas.width; 
                const targetY = indexTip.y * canvas.height;

                state.cursor.x += (targetX - state.cursor.x) * CONFIG.vision.smoothing;
                state.cursor.y += (targetY - state.cursor.y) * CONFIG.vision.smoothing;

                // Update Detected Status
                document.getElementById('detect-dot').className = 'status-dot green';

                // --- AUTO MODE LOGIC ---
                if (state.shootingMode === 'AUTO') {
                    if (state.autoFireCooldown > 0) state.autoFireCooldown--;

                    // Check collision directly
                    let aimedAtDuck = false;
                    for (let duck of state.ducks) {
                        if (duck.checkCollision(state.cursor.x, state.cursor.y)) {
                            aimedAtDuck = true;
                            if (state.autoFireCooldown === 0) {
                                fireShot();
                                state.autoFireCooldown = 15; // Delay
                            }
                            break;
                        }
                    }
                } 
                // --- MANUAL MODE LOGIC ---
                else {
                    const wrist = landmarks[0];
                    const middleMCP = landmarks[9];
                    const handSize = Math.sqrt(Math.pow(middleMCP.x - wrist.x, 2) + Math.pow(middleMCP.y - wrist.y, 2));

                    const thumbTip = landmarks[4];
                    const thumbIP = landmarks[3];

                    const thumbVerticalOffset = (thumbIP.y - thumbTip.y) / handSize; 

                    const COCKED_THRESHOLD = 0.05; 
                    const FIRED_THRESHOLD = -0.02; 
                    
                    if (state.triggerState === 'IDLE' || state.triggerState === 'READY') {
                        if (thumbVerticalOffset > COCKED_THRESHOLD) {
                            state.triggerState = 'READY';
                            document.getElementById('ready-dot').className = 'status-dot green';
                        } else {
                            state.triggerState = 'IDLE';
                            document.getElementById('ready-dot').className = 'status-dot red';
                        }
                    }

                    if (state.triggerState === 'READY') {
                        if (thumbVerticalOffset < FIRED_THRESHOLD) {
                            fireShot();
                            state.triggerState = 'COOLDOWN';
                            document.getElementById('ready-dot').className = 'status-dot yellow';
                            setTimeout(() => { state.triggerState = 'IDLE'; }, 200);
                        }
                    }
                }

            } else {
                state.handDetected = false;
                document.getElementById('detect-dot').className = 'status-dot red';
                if(state.shootingMode === 'MANUAL') document.getElementById('ready-dot').className = 'status-dot red';
            }
        }

        function fireShot() {
            state.shots.push({ x: state.cursor.x, y: state.cursor.y, life: 5 });
            playShootSound();

            let hit = false;
            for (let duck of state.ducks) {
                if (duck.checkCollision(state.cursor.x, state.cursor.y)) {
                    duck.hit();
                    hit = true;
                    playHitSound();
                    break;
                }
            }
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(0,0, canvas.width, canvas.height);
    }
    // --- RENDER LOOP ---

        function drawBackground() {
            ctx.fillStyle = CONFIG.colors.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const groundY = canvas.height * CONFIG.game.groundLevelRatio;

            ctx.fillStyle = CONFIG.colors.grass;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            ctx.fillStyle = CONFIG.colors.dirt;
            ctx.fillRect(0, groundY, canvas.width, 10);

            drawTree(50, groundY - 150);
            drawBush(canvas.width - 200, groundY - 50);
        }

        function drawTree(x, y) {
            ctx.fillStyle = '#663931';
            ctx.fillRect(x + 30, y + 80, 20, 70);
            ctx.fillStyle = '#2d4c1e';
            ctx.fillRect(x, y, 80, 80);
            ctx.fillStyle = '#4b692f';
            ctx.fillRect(x + 10, y + 10, 60, 60);
        }

        function drawBush(x, y) {
            ctx.fillStyle = '#2d4c1e';
            ctx.fillRect(x, y, 100, 50);
            ctx.fillStyle = '#83D313'; 
            ctx.fillRect(x + 10, y + 10, 20, 10);
            ctx.fillRect(x + 60, y + 20, 20, 10);
        }

        function drawCursor() {
            const x = state.cursor.x;
            const y = state.cursor.y;
            
            let color = '#FFFFFF';
            if (state.shootingMode === 'AUTO') color = CONFIG.colors.crosshairAuto;
            else if (state.triggerState === 'READY') color = CONFIG.colors.crosshair;

            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x - 25, y);
            ctx.lineTo(x + 25, y);
            ctx.moveTo(x, y - 25);
            ctx.lineTo(x, y + 25);
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMuzzleFlash(shot) {
            const x = shot.x;
            const y = shot.y;
            const size = shot.life * 10;
            
            ctx.fillStyle = CONFIG.colors.crosshairReload;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * size + x,
                           Math.sin((18 + i * 72) / 180 * Math.PI) * size + y);
                ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * (size/2) + x,
                           Math.sin((54 + i * 72) / 180 * Math.PI) * (size/2) + y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            if (state.ducks.length < CONFIG.game.maxDucks && Math.random() < 0.02) {
                state.ducks.push(new Duck(canvas.width, canvas.height));
            }

            state.ducks = state.ducks.filter(duck => {
                const alive = duck.update(canvas.width, canvas.height);
                duck.render(ctx);
                return alive;
            });

            state.shots = state.shots.filter(shot => {
                drawMuzzleFlash(shot);
                shot.life--;
                return shot.life > 0;
            });

            if (state.handDetected) {
                drawCursor();
            }
            requestAnimationFrame(gameLoop);
        }

        // --- MEDIAPIPE INITIALIZATION ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

    </script>
</body>
</html>
